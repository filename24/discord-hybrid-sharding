{"version":3,"sources":["../src/index.ts","../src/Core/Cluster.ts","../src/Util/Util.ts","../src/types/shared.ts","../src/Structures/IPCMessage.ts","../src/Structures/IPCHandler.ts","../src/Structures/Worker.ts","../src/Structures/Child.ts","../src/Structures/Data.ts","../src/Structures/PromiseHandler.ts","../src/Core/ClusterClient.ts","../src/Core/ClusterManager.ts","../src/Structures/Queue.ts","../src/Plugins/HeartbeatSystem.ts","../src/Plugins/ReCluster.ts"],"sourcesContent":["export * from './Core/Cluster';\nexport * from './Core/ClusterClient';\nexport * from './Core/ClusterManager';\nexport * from './Plugins/HeartbeatSystem';\nexport * from './Plugins/ReCluster';\nexport * from './Structures/Child';\nexport * from './Structures/Data';\nexport * from './Structures/IPCHandler';\nexport * from './Structures/IPCMessage';\nexport * from './Structures/PromiseHandler';\nexport * from './Structures/Queue';\nexport * from './Structures/Worker';\nexport * from './types/shared';\nexport * from './Util/Util';\n","import { ClusterManager } from './ClusterManager';\n\nimport EventEmitter from 'events';\nimport path from 'path';\nimport { delayFor, generateNonce } from '../Util/Util';\n\nimport { ClusterEvents, ClusterKillOptions, messageType } from '../types/shared';\nimport { IPCMessage, BaseMessage, RawMessage } from '../Structures/IPCMessage.js';\nimport { ClusterHandler } from '../Structures/IPCHandler.js';\n\nimport { Worker } from '../Structures/Worker.js';\nimport { Child } from '../Structures/Child.js';\nimport { Serializable } from 'child_process';\n\n/**\n * A self-contained cluster created by the {@link ClusterManager}. Each one has a {@link Child} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the cluster will\n * spawn a new one to replace it as necessary.\n * @augments EventEmitter\n */\nexport class Cluster extends EventEmitter {\n    THREAD: typeof Worker | typeof Child;\n\n    /**\n     * Manager that created the cluster\n     */\n    manager: ClusterManager;\n\n    /**\n     * ID of the cluster in the manager\n     */\n    id: number;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     */\n    args: string[];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     */\n    execArgv: string[];\n\n    /**\n     * Internal Shards which will get spawned in the cluster\n     */\n    shardList: number[];\n\n    /**\n     * the amount of real shards\n     */\n    totalShards: number;\n\n    /**\n     * Environment variables for the cluster's process, or workerData for the cluster's worker\n     */\n    env: NodeJS.ProcessEnv & {\n        SHARD_LIST: number[];\n        TOTAL_SHARDS: number;\n        CLUSTER_MANAGER: boolean;\n        CLUSTER: number;\n        CLUSTER_COUNT: number;\n        DISCORD_TOKEN: string;\n    };\n\n    /**\n     * Process of the cluster (if {@link ClusterManager#mode} is `process`)\n     */\n    thread: null | Worker | Child;\n\n    restarts: {\n        current: number;\n        max: number;\n        interval: number;\n        reset?: NodeJS.Timer;\n        resetRestarts: () => void;\n        cleanup: () => void;\n        append: () => void;\n    };\n\n    messageHandler: any;\n\n    /**\n     * Whether the cluster's {@link Client} is ready\n     */\n    ready: boolean;\n\n    /**\n     * @param manager Manager that is creating this cluster\n     * @param id ID of this cluster\n     * @param shardList\n     * @param totalShards\n     */\n    constructor(manager: ClusterManager, id: number, shardList: number[], totalShards: number) {\n        super();\n\n        this.THREAD = manager.mode === 'worker' ? Worker : Child;\n\n        this.manager = manager;\n\n        this.id = id;\n\n        this.args = manager.shardArgs || [];\n\n        this.execArgv = manager.execArgv;\n\n        this.shardList = shardList;\n\n        this.totalShards = totalShards;\n\n        this.env = Object.assign({}, process.env, {\n            SHARD_LIST: this.shardList,\n            TOTAL_SHARDS: this.totalShards,\n            CLUSTER_MANAGER: true,\n            CLUSTER: this.id,\n            CLUSTER_COUNT: this.manager.totalClusters,\n            DISCORD_TOKEN: this.manager.token as string,\n        });\n\n        this.ready = false;\n\n        this.thread = null;\n\n        this.restarts = {\n            current: this.manager.restarts.current ?? 0,\n            max: this.manager.restarts.max,\n            interval: this.manager.restarts.interval,\n            reset: undefined,\n            resetRestarts: () => {\n                this.restarts.reset = setInterval(() => {\n                    this.restarts.current = 0;\n                }, this.manager.restarts.interval);\n            },\n            cleanup: () => {\n                if (this.restarts.reset) clearInterval(this.restarts.reset);\n            },\n            append: () => {\n                this.restarts.current++;\n            },\n        };\n    }\n    /**\n     * Forks a child process or creates a worker thread for the cluster.\n     * <warn>You should not need to call this manually.</warn>\n     * @param spawnTimeout The amount in milliseconds to wait until the {@link Client} has become ready\n     * before resolving. (-1 or Infinity for no wait)\n     */\n    public async spawn(spawnTimeout = 30000) {\n        if (this.thread) throw new Error('CLUSTER ALREADY SPAWNED | ClusterId: ' + this.id);\n        this.thread = new this.THREAD(path.resolve(this.manager.file), {\n            ...this.manager.clusterOptions,\n            execArgv: this.execArgv,\n            env: this.env,\n            args: this.args,\n            clusterData: { ...this.env, ...this.manager.clusterData },\n        });\n        this.messageHandler = new ClusterHandler(this.manager, this, this.thread);\n\n        this.thread\n            .spawn()\n            .on('message', this._handleMessage.bind(this))\n            .on('exit', this._handleExit.bind(this))\n            .on('error', this._handleError.bind(this));\n\n        /**\n         * Emitted upon the creation of the cluster's child process/worker.\n         * @event Cluster#spawn\n         * @param {Child|Worker} process Child process/worker that was created\n         */\n        this.emit('spawn', this.thread.process);\n\n        if (spawnTimeout === -1 || spawnTimeout === Infinity) return this.thread.process;\n\n        await new Promise((resolve, reject) => {\n            const cleanup = () => {\n                clearTimeout(spawnTimeoutTimer);\n                this.off('ready', onReady);\n                this.off('death', onDeath);\n            };\n\n            const onReady = () => {\n                this.manager.emit('clusterReady', this);\n                this.restarts.cleanup();\n                this.restarts.resetRestarts();\n                cleanup();\n                resolve('Cluster is ready');\n            };\n\n            const onDeath = () => {\n                cleanup();\n                reject(new Error('CLUSTERING_READY_DIED | ClusterId: ' + this.id));\n            };\n\n            const onTimeout = () => {\n                cleanup();\n                reject(new Error('CLUSTERING_READY_TIMEOUT | ClusterId: ' + this.id));\n            };\n\n            const spawnTimeoutTimer = setTimeout(onTimeout, spawnTimeout);\n            this.once('ready', onReady);\n            this.once('death', onDeath);\n        });\n        return this.thread.process;\n    }\n    /**\n     * Immediately kills the clusters process/worker and does not restart it.\n     * @param options Some Options for managing the Kill\n     * @param options.force Whether the Cluster should be force kill and be ever respawned...\n     */\n    public kill(options: ClusterKillOptions) {\n        this.thread?.kill();\n        if(this.thread){\n            this.thread = null;\n        }\n        this.manager.heartbeat?.clusters.get(this.id)?.stop();\n        this.restarts.cleanup();\n        this.manager._debug('[KILL] Cluster killed with reason: ' + (options?.reason || 'not given'), this.id);\n    }\n    /**\n     * Kills and restarts the cluster's process/worker.\n     * @param options Options for respawning the cluster\n     */\n    public async respawn({ delay = 500, timeout = 30000 } = this.manager.spawnOptions) {\n        if (this.thread) this.kill({ force: true });\n        if (delay > 0) await delayFor(delay);\n        this.manager.heartbeat?.clusters.get(this.id)?.stop();\n        return this.spawn(timeout);\n    }\n    /**\n     * Sends a message to the cluster's process/worker.\n     * @param  message Message to send to the cluster\n     */\n    public send(message: RawMessage) {\n        if (typeof message === 'object') this.thread?.send(new BaseMessage(message).toJSON());\n        else return this.thread?.send(message);\n    }\n\n    /**\n     * Sends a Request to the ClusterClient and returns the reply\n     * @param message Message, which should be sent as request\n     * @returns Reply of the Message\n     * @example\n     * client.cluster.request({content: 'hello'})\n     *   .then(result => console.log(result)) //hi\n     *   .catch(console.error);\n     * @see {@link IPCMessage#reply}\n     */\n    public request(message: RawMessage) {\n        message._type = messageType.CUSTOM_REQUEST;\n        this.send(message);\n        return this.manager.promise.create(message, message.options);\n    }\n    /**\n     * Evaluates a script or function on the cluster, in the context of the {@link Client}.\n     * @param script JavaScript to run on the cluster\n     * @param context\n     * @param timeout\n     * @returns Result of the script execution\n     */\n    public async eval(script: string, context: any, timeout: number) {\n        // Stringify the script if it's a Function\n        const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script;\n\n        // cluster is dead (maybe respawning), don't cache anything and error immediately\n        if (!this.thread) return Promise.reject(new Error('CLUSTERING_NO_CHILD_EXISTS | ClusterId: ' + this.id));\n        const nonce = generateNonce();\n        const message = { nonce, _eval, options: { timeout }, _type: messageType.CLIENT_EVAL_REQUEST };\n        await this.send(message);\n        return await this.manager.promise.create(message, message.options);\n    }\n\n    /**\n     * @param reason If maintenance should be enabled with a given reason or disabled when nonce provided\n     */\n    public triggerMaintenance(reason?: string) {\n        const _type = reason ? messageType.CLIENT_MAINTENANCE_ENABLE : messageType.CLIENT_MAINTENANCE_DISABLE;\n        return this.send({ _type, maintenance: reason });\n    }\n\n    /**\n     * Handles a message received from the child process/worker.\n     * @param message Message received\n     * @private\n     */\n    private _handleMessage(message: Serializable) {\n        if (!message) return;\n        const emit = this.messageHandler.handleMessage(message);\n        if (!emit) return;\n\n        let emitMessage;\n        if (typeof message === 'object') {\n            emitMessage = new IPCMessage(this, message);\n            if (emitMessage._type === messageType.CUSTOM_REQUEST) this.manager.emit('clientRequest', emitMessage);\n        } else emitMessage = message;\n        /**\n         * Emitted upon receiving a message from the child process/worker.\n         * @event Shard#message\n         * @param {*|IPCMessage} message Message that was received\n         */\n        this.emit('message', emitMessage);\n    }\n\n    /**\n     * Handles the cluster's process/worker exiting.\n     * @private\n     * @param {Number} exitCode\n     */\n    private _handleExit(exitCode: number) {\n        /**\n         * Emitted upon the cluster's child process/worker exiting.\n         * @event Cluster#death\n         * @param {Child|Worker} process Child process/worker that exited\n         */\n\n        const respawn = this.manager.respawn;\n\n        // Cleanup functions\n        this.manager.heartbeat?.clusters.get(this.id)?.stop();\n        this.restarts.cleanup();\n\n        this.emit('death', this, this.thread?.process);\n\n        this.manager._debug(\n            '[DEATH] Cluster died, attempting respawn | Restarts Left: ' + (this.restarts.max - this.restarts.current),\n            this.id,\n        );\n\n        this.ready = false;\n\n        this.thread = null;\n\n        if (!respawn) return;\n\n        if (this.restarts.current >= this.restarts.max)\n            this.manager._debug(\n                '[ATTEMPTED_RESPAWN] Attempted Respawn Declined | Max Restarts have been exceeded',\n                this.id,\n            );\n        if (respawn && this.restarts.current < this.restarts.max) this.spawn().catch(err => this.emit('error', err));\n\n        this.restarts.append();\n    }\n\n    /**\n     * Handles the cluster's process/worker error.\n     * @param  error the error, which occurred on the worker/child process\n     * @private\n     */\n    private _handleError(error: Error) {\n        /**\n         * Emitted upon the cluster's child process/worker error.\n         * @event Cluster#error\n         * @param {Child|Worker} process Child process/worker, where error occurred\n         */\n        this.manager.emit('error', error);\n    }\n}\n\n// Credits for EventEmitter typings: https://github.com/discordjs/discord.js/blob/main/packages/rest/src/lib/RequestManager.ts#L159 | See attached license\nexport interface Cluster {\n    emit: (<K extends keyof ClusterEvents>(event: K, ...args: ClusterEvents[K]) => boolean) &\n        (<S extends string | symbol>(event: Exclude<S, keyof ClusterEvents>, ...args: any[]) => boolean);\n\n    off: (<K extends keyof ClusterEvents>(event: K, listener: (...args: ClusterEvents[K]) => void) => this) &\n        (<S extends string | symbol>(\n            event: Exclude<S, keyof ClusterEvents>,\n            listener: (...args: any[]) => void,\n        ) => this);\n\n    on: (<K extends keyof ClusterEvents>(event: K, listener: (...args: ClusterEvents[K]) => void) => this) &\n        (<S extends string | symbol>(\n            event: Exclude<S, keyof ClusterEvents>,\n            listener: (...args: any[]) => void,\n        ) => this);\n\n    once: (<K extends keyof ClusterEvents>(event: K, listener: (...args: ClusterEvents[K]) => void) => this) &\n        (<S extends string | symbol>(\n            event: Exclude<S, keyof ClusterEvents>,\n            listener: (...args: any[]) => void,\n        ) => this);\n\n    removeAllListeners: (<K extends keyof ClusterEvents>(event?: K) => this) &\n        (<S extends string | symbol>(event?: Exclude<S, keyof ClusterEvents>) => this);\n}\n","import fetch from 'node-fetch';\nimport { DefaultOptions, Endpoints } from '../types/shared';\n\nexport function generateNonce() {\n    return Date.now().toString(36) + Math.random().toString(36);\n}\n\nexport function chunkArray(array: any[], chunkSize: number) {\n    const R = [];\n    for (let i = 0; i < array.length; i += chunkSize) R.push(array.slice(i, i + chunkSize));\n    return R;\n}\n\nexport function delayFor(ms: number) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n\nexport function makePlainError(err: Error) {\n    return {\n        name: err['name'],\n        message: err['message'],\n        stack: err['stack'],\n    };\n}\n\nexport function shardIdForGuildId(guildId: string, totalShards = 1) {\n    const shard = Number(BigInt(guildId) >> BigInt(22)) % totalShards;\n    if (shard < 0)\n        throw new Error(\n            'SHARD_MISCALCULATION_SHARDID_SMALLER_THAN_0 ' +\n                `Calculated Shard: ${shard}, guildId: ${guildId}, totalShards: ${totalShards}`,\n        );\n    return shard;\n}\n\nexport async function fetchRecommendedShards(token: string, guildsPerShard = 1000) {\n    if (!token) throw new Error('DISCORD_TOKEN_MISSING');\n    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {\n        method: 'GET',\n        headers: { Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}` },\n    })\n        .then(res => {\n            if (res.ok) return res.json() as Promise<{ shards: number }>;\n            if (res.status === 401) throw new Error('DISCORD_TOKEN_INVALID');\n            throw res;\n        })\n        .then(data => data.shards * (1000 / guildsPerShard));\n}\n","import { ChildProcess, Serializable } from 'child_process';\nimport { Worker } from 'worker_threads';\nimport { Cluster } from '../Core/Cluster';\nimport { ClusterClient } from '../Core/ClusterClient';\nimport { ClusterManager } from '../Core/ClusterManager';\nimport { ChildProcessOptions } from '../Structures/Child';\nimport { BaseMessage } from '../Structures/IPCMessage';\nimport { WorkerThreadOptions } from '../Structures/Worker';\nimport { Client } from 'discord.js';\n\nexport const Events = {\n    ERROR: 'warn',\n    WARN: 'error',\n};\n\nexport const DefaultOptions = {\n    http: {\n        api: 'https://discord.com/api',\n        version: '10',\n    },\n};\n\nexport const Endpoints = {\n    botGateway: '/gateway/bot',\n};\n\nexport enum messageType {\n    'MISSING_TYPE',\n    'CUSTOM_REQUEST',\n    'CUSTOM_MESSAGE',\n    'CUSTOM_REPLY',\n    'HEARTBEAT',\n    'HEARTBEAT_ACK',\n    'CLIENT_BROADCAST_REQUEST',\n    'CLIENT_BROADCAST_RESPONSE',\n    'CLIENT_RESPAWN',\n    'CLIENT_RESPAWN_ALL',\n    'CLIENT_MAINTENANCE',\n    'CLIENT_MAINTENANCE_ENABLE',\n    'CLIENT_MAINTENANCE_DISABLE',\n    'CLIENT_MAINTENANCE_ALL',\n    'CLIENT_SPAWN_NEXT_CLUSTER',\n    'CLIENT_READY',\n    'CLIENT_EVAL_REQUEST',\n    'CLIENT_EVAL_RESPONSE',\n    'CLIENT_MANAGER_EVAL_REQUEST',\n    'CLIENT_MANAGER_EVAL_RESPONSE',\n    'MANAGER_BROADCAST_REQUEST',\n    'MANAGER_BROADCAST_RESPONSE',\n}\n\nexport interface evalOptions<T = object> {\n    cluster?: number | number[];\n    shard?: number;\n    guildId?: string;\n    context?: T;\n    timeout?: number;\n    _type?: messageType;\n}\n\nexport type Awaitable<T> = T | PromiseLike<T>;\n\nexport type Serialized<T> = T extends symbol | bigint | (() => any)\n    ? never\n    : T extends number | string | boolean | undefined\n    ? T\n    : T extends { toJSON(): infer R }\n    ? R\n    : T extends ReadonlyArray<infer V>\n    ? Serialized<V>[]\n    : T extends ReadonlyMap<unknown, unknown> | ReadonlySet<unknown>\n    ? {}\n    : { [K in keyof T]: Serialized<T[K]> };\n\nexport interface ClusterSpawnOptions {\n    delay?: number;\n    timeout?: number;\n}\n\nexport interface ClusterManagerSpawnOptions extends ClusterSpawnOptions {\n    amount?: number | 'auto';\n}\n\nexport interface ClusterManagerOptions {\n    /** The token of the discord bot */\n    token?: string;\n    /** Number of total internal shards or \"auto\" */\n    totalShards?: number | 'auto';\n    /** Number of total Clusters\\Process to spawn*/\n    totalClusters?: number | 'auto';\n    /** Number of shards per cluster*/\n    shardsPerClusters?: number;\n    /** Arguments to pass to the clustered script when spawning (only available when using the `process` mode)*/\n    shardArgs?: string[];\n    /** Arguments to pass to the clustered script executable when spawning*/\n    execArgv?: string[];\n    /** Whether clusters should automatically respawn upon exiting */\n    respawn?: boolean;\n    /** Which mode to use for clustering */\n    mode?: 'worker' | 'process';\n    /** An Array of Internal Shards Ids, which should get spawned */\n    shardList?: number[];\n    /** An Array of Ids to assign to the spawned Clusters, when the default id scheme is not wanted */\n    clusterList?: number[];\n    /** Restart options */\n    restarts?: ClusterRestartOptions;\n    /** Control the Spawn Queue */\n    queue?: QueueOptions;\n    /** Options to pass to the spawn,respawn method */\n    spawnOptions?: ClusterManagerSpawnOptions;\n    /** Data, which is passed to the Cluster */\n    clusterData?: object;\n    /** @deprecated keepAlive is not supported anymore on and above v1.6.0. Import it as plugin (\"HeartbeatManager\") */\n    keepAlive?: boolean;\n    /** Options, which is passed when forking a child or creating a thread */\n    clusterOptions?: ChildProcessOptions | WorkerThreadOptions;\n}\n\nexport interface ClusterRestartOptions {\n    /** Maximum amount of restarts a cluster can have in the interval */\n    max: number;\n    /** Interval in milliseconds on which the current restarts amount of a cluster will be resetted */\n    interval: number;\n    /** Current Amount of restarts */\n    current?: number;\n}\n\nexport interface QueueOptions {\n    /** Whether the spawn queue be automatically managed */\n    auto: boolean;\n    /** Time to wait until next item */\n    timeout?: number;\n}\n\nexport interface ClusterKillOptions {\n    reason?: string;\n    force: boolean;\n}\n\nexport interface Plugin {\n    build(manager: ClusterManager): void;\n}\n\n// Events\nexport interface ClusterManagerEvents {\n    clusterCreate: [cluster: Cluster];\n    clusterReady: [cluster: Cluster];\n    debug: [debugMessage: string];\n}\n\nexport interface ClusterEvents {\n    message: [message: BaseMessage | Serializable];\n    clientRequest: [message: BaseMessage | Serializable];\n    death: [cluster: Cluster, thread: ChildProcess | Worker | undefined | null];\n    error: [error: Error];\n    spawn: [thread: ChildProcess | Worker | undefined | null];\n}\n\nexport interface ClusterClientEvents<DiscordClient> {\n    message: [message: BaseMessage | Serializable];\n    ready: [clusterClient: ClusterClient<DiscordClient>];\n}\n\n\nexport interface DjsDiscordClient extends Client {\n\n}\n","import { generateNonce } from '../Util/Util';\nimport { messageType } from '../types/shared';\nimport { ClusterClient } from '../Core/ClusterClient';\nimport { Cluster } from '../Core/Cluster';\n\nexport interface RawMessage {\n    nonce?: string;\n    _type?: number;\n    [x: string]: any;\n}\n\nexport class BaseMessage {\n    [x: string]: any;\n    nonce: string;\n    private readonly _raw: RawMessage;\n    constructor(message: RawMessage) {\n        /**\n         * Creates a Message ID for identifying it for further Usage such as on replies\n         */\n        this.nonce = message.nonce || generateNonce();\n        message.nonce = this.nonce;\n\n        /**\n         * Destructs the Message Object and initializes it on the Constructor\n         */\n        this._raw = this.destructMessage(message);\n    }\n\n    /**\n     * Destructs the Message Object and initializes it on the Constructor\n     */\n    private destructMessage(message: RawMessage) {\n        for (const [key, value] of Object.entries(message)) {\n            this[key] = value;\n        }\n        if (message.nonce) this.nonce = message.nonce;\n        this._type = message._type || messageType.CUSTOM_MESSAGE;\n        return message;\n    }\n\n    public toJSON() {\n        return this._raw;\n    }\n}\n\nexport class IPCMessage extends BaseMessage {\n    raw: RawMessage;\n    instance: ClusterClient<any> | Cluster;\n    constructor(instance: ClusterClient<any> | Cluster, message: RawMessage) {\n        super(message);\n\n        /**\n         * Instance, which can be the ParentCluster or the ClusterClient\n         */\n        this.instance = instance;\n\n        /**\n         * The Base Message, which is saved on the raw field.\n         */\n        this.raw = new BaseMessage(message).toJSON();\n    }\n\n    /**\n     * Sends a message to the cluster's process/worker or to the ParentCluster.\n     */\n    public async send(message: object) {\n        if (typeof message !== 'object') throw new TypeError('The Message has to be a object');\n        const baseMessage = new BaseMessage({ ...message, _type: messageType.CUSTOM_MESSAGE });\n        return this.instance.send(baseMessage.toJSON());\n    }\n\n    /**\n     * Sends a Request to the cluster's process/worker or to the ParentCluster.\n     */\n    public async request(message: object) {\n        if (typeof message !== 'object') throw new TypeError('The Message has to be a object');\n        const baseMessage = new BaseMessage({ ...message, _type: messageType.CUSTOM_REQUEST, nonce: this.nonce });\n        return this.instance.request(baseMessage.toJSON());\n    }\n\n    /**\n     * Sends a Reply to Message from the cluster's process/worker or the ParentCluster.\n     */\n    public async reply(message: object) {\n        if (typeof message !== 'object') throw new TypeError('The Message has to be a object');\n        const baseMessage = new BaseMessage({\n            ...message,\n            _type: messageType.CUSTOM_REPLY,\n            nonce: this.nonce,\n            _result: message,\n        });\n        return this.instance.send(baseMessage.toJSON());\n    }\n}\n","import { Cluster } from '../Core/Cluster';\nimport { ClusterClient } from '../Core/ClusterClient';\nimport { ClusterManager } from '../Core/ClusterManager';\nimport { messageType } from '../types/shared';\nimport { makePlainError } from '../Util/Util';\nimport { Child, ChildClient } from './Child';\nimport { RawMessage } from './IPCMessage';\nimport { ResolveMessage } from './PromiseHandler';\nimport { Worker, WorkerClient } from './Worker';\n\nexport class ClusterHandler {\n    manager: ClusterManager;\n    cluster: Cluster;\n    ipc: Worker | Child;\n    constructor(manager: ClusterManager, cluster: Cluster, ipc: Worker | Child) {\n        this.manager = manager;\n        this.cluster = cluster;\n        this.ipc = ipc;\n    }\n\n    handleMessage(message: RawMessage) {\n        if (message._type === messageType.CLIENT_READY) {\n            this.cluster.ready = true;\n            /**\n             * Emitted upon the cluster's {@link Client#ready} event.\n             * @event Cluster#ready\n             */\n            this.cluster.emit('ready');\n            this.cluster.manager._debug('Ready', this.cluster.id);\n            return;\n        }\n        if (message._type === messageType.CLIENT_BROADCAST_REQUEST) {\n            this.cluster.manager\n                .broadcastEval(message._eval, message.options)\n                ?.then(results => {\n                    return this.ipc.send({\n                        nonce: message.nonce,\n                        _type: messageType.CLIENT_BROADCAST_RESPONSE,\n                        _result: results,\n                    });\n                })\n                .catch(err => {\n                    return this.ipc.send({\n                        nonce: message.nonce,\n                        _type: messageType.CLIENT_BROADCAST_RESPONSE,\n                        _error: makePlainError(err),\n                    });\n                });\n            return;\n        }\n        if (message._type === messageType.CLIENT_MANAGER_EVAL_REQUEST) {\n            this.cluster.manager.evalOnManager(message._eval).then(result => {\n                if (result._error)\n                    this.ipc.send({\n                        nonce: message.nonce,\n                        _type: messageType.CLIENT_MANAGER_EVAL_RESPONSE,\n                        _error: makePlainError(result._error),\n                    });\n                return this.ipc.send({\n                    nonce: message.nonce,\n                    _type: messageType.CLIENT_MANAGER_EVAL_RESPONSE,\n                    _result: result._result,\n                });\n            });\n            return;\n        }\n        if (message._type === messageType.CLIENT_EVAL_RESPONSE) {\n            this.cluster.manager.promise.resolve(message as ResolveMessage);\n            return;\n        }\n        if (message._type === messageType.CLIENT_RESPAWN_ALL) {\n            this.cluster.manager.respawnAll(message.options);\n            return;\n        }\n        if (message._type === messageType.CLIENT_RESPAWN) {\n            this.cluster.respawn(message.options);\n            return;\n        }\n        if (message._type === messageType.CLIENT_MAINTENANCE) {\n            this.cluster.triggerMaintenance(message.maintenance);\n            return;\n        }\n        if (message._type === messageType.CLIENT_MAINTENANCE_ALL) {\n            this.cluster.manager.triggerMaintenance(message.maintenance);\n            return;\n        }\n        if (message._type === messageType.CLIENT_SPAWN_NEXT_CLUSTER) {\n            this.cluster.manager.queue.next();\n            return;\n        }\n        if (message._type === messageType.HEARTBEAT_ACK) {\n            this.cluster.manager.heartbeat?.ack(this.cluster.id, message.date);\n            return;\n        }\n        if (message._type === messageType.CUSTOM_REPLY) {\n            this.cluster.manager.promise.resolve(message as ResolveMessage);\n            return;\n        }\n        return true;\n    }\n}\n\nexport class ClusterClientHandler<DiscordClient> {\n    client: ClusterClient<DiscordClient>;\n    ipc: ChildClient | WorkerClient | null;\n    constructor(client: ClusterClient<DiscordClient>, ipc: ChildClient | WorkerClient | null) {\n        this.client = client;\n        this.ipc = ipc;\n    }\n\n    public async handleMessage(message: ResolveMessage & { date?: number; maintenance?: string }) {\n        if (message._type === messageType.CLIENT_EVAL_REQUEST) {\n            try {\n                if (!message._eval) throw new Error('Eval Script not provided');\n                this.client._respond('eval', {\n                    _eval: message._eval,\n                    _result: await this.client._eval(message._eval),\n                    _type: messageType.CLIENT_EVAL_RESPONSE,\n                    nonce: message.nonce,\n                });\n            } catch (err) {\n                this.client._respond('eval', {\n                    _eval: message._eval,\n                    _error: makePlainError(err),\n                    _type: messageType.CLIENT_EVAL_RESPONSE,\n                    nonce: message.nonce,\n                });\n            }\n            return null;\n        }\n        if (message._type === messageType.CLIENT_MANAGER_EVAL_RESPONSE) {\n            this.client.promise.resolve({ _result: message._result, _error: message._error, nonce: message.nonce });\n            return null;\n        }\n        if (message._type === messageType.CLIENT_BROADCAST_RESPONSE) {\n            this.client.promise.resolve({ _result: message._result, _error: message._error, nonce: message.nonce });\n            return null;\n        }\n        if (message._type === messageType.HEARTBEAT) {\n            this.client.send({ _type: messageType.HEARTBEAT_ACK, date: message.date });\n            return null;\n        }\n        if (message._type === messageType.CLIENT_MAINTENANCE_DISABLE) {\n            this.client.maintenance = false;\n            this.client.triggerClusterReady();\n            return null;\n        }\n        if (message._type === messageType.CLIENT_MAINTENANCE_ENABLE) {\n            this.client.maintenance = message.maintenance || true;\n            return null;\n        }\n        if (message._type === messageType.CUSTOM_REPLY) {\n            this.client.promise.resolve(message);\n            return null;\n        }\n        return true;\n    }\n}\n","import { Serializable } from 'child_process';\nimport { Worker as Worker_Thread, WorkerOptions, parentPort, workerData } from 'worker_threads';\n\nexport interface WorkerThreadOptions extends WorkerOptions {\n    clusterData: any;\n}\n\nexport class Worker {\n    file: string;\n    process: Worker_Thread | null;\n    workerOptions: WorkerOptions;\n    constructor(file: string, options: WorkerThreadOptions) {\n        this.file = file;\n        this.process = null;\n\n        this.workerOptions = {};\n\n        // Custom options\n        if (options.clusterData) this.workerOptions.workerData = options.clusterData;\n\n        if (options.argv) this.workerOptions.argv = options.argv;\n        if (options.execArgv) this.workerOptions.execArgv = options.execArgv;\n        if (options.env) this.workerOptions.env = options.env;\n        if (options.eval) this.workerOptions.eval = options.eval;\n        if (options.stdin) this.workerOptions.stdin = options.stdin;\n        if (options.stdout) this.workerOptions.stdout = options.stdout;\n        if (options.stderr) this.workerOptions.stderr = options.stderr;\n        if (options.trackUnmanagedFds) this.workerOptions.trackUnmanagedFds = options.trackUnmanagedFds;\n        if (options.transferList) this.workerOptions.transferList = options.transferList;\n        if (options.resourceLimits) this.workerOptions.resourceLimits = options.resourceLimits;\n    }\n\n    public spawn() {\n        return (this.process = new Worker_Thread(this.file, this.workerOptions));\n    }\n\n    public respawn() {\n        this.kill();\n        return this.spawn();\n    }\n\n    public kill() {\n        this.process?.removeAllListeners();\n        return this.process?.terminate();\n    }\n\n    public send(message: Serializable) {\n        return new Promise(resolve => {\n            this.process?.postMessage(message);\n            resolve(this);\n        });\n    }\n}\n\nexport class WorkerClient {\n    ipc: typeof parentPort;\n    constructor() {\n        this.ipc = parentPort;\n    }\n\n    public send(message: Serializable) {\n        return new Promise<void>(resolve => {\n            this.ipc?.postMessage(message);\n            resolve();\n        });\n    }\n\n    public getData() {\n        return workerData;\n    }\n}\n","import { ChildProcess, fork, ForkOptions, Serializable } from 'child_process';\n\nexport interface ChildProcessOptions extends ForkOptions {\n    clusterData: NodeJS.ProcessEnv | undefined;\n    args?: string[] | undefined;\n}\n\nexport class Child {\n    file: string;\n    process: ChildProcess | null;\n    processOptions: ForkOptions;\n    args?: string[];\n    constructor(file: string, options: ChildProcessOptions) {\n        this.file = file;\n        this.process = null;\n\n        this.processOptions = {};\n\n        // Custom options\n        if (options.clusterData) this.processOptions.env = options.clusterData;\n\n        if (options.args) this.args = options.args;\n\n        if (options.cwd) this.processOptions.cwd = options.cwd;\n        if (options.detached) this.processOptions.detached = options.detached;\n        if (options.execArgv) this.processOptions.execArgv = options.execArgv;\n        if (options.env) this.processOptions.env = options.env;\n        if (options.execPath) this.processOptions.execPath = options.execPath;\n        if (options.gid) this.processOptions.gid = options.gid;\n\n        if (options.serialization) this.processOptions.serialization = options.serialization;\n        if (options.signal) this.processOptions.signal = options.signal;\n        if (options.killSignal) this.processOptions.killSignal = options.killSignal;\n        if (options.silent) this.processOptions.silent = options.silent;\n\n        if (options.stdio) this.processOptions.stdio = options.stdio;\n        if (options.uid) this.processOptions.uid = options.uid;\n\n        if (options.windowsVerbatimArguments)\n            this.processOptions.windowsVerbatimArguments = options.windowsVerbatimArguments;\n        if (options.timeout) this.processOptions.timeout = options.timeout;\n    }\n\n    public spawn() {\n        return (this.process = fork(this.file, this.args, this.processOptions));\n    }\n\n    public respawn() {\n        this.kill();\n        return this.spawn();\n    }\n\n    public kill() {\n        this.process?.removeAllListeners();\n        return this.process?.kill();\n    }\n\n    public send(message: Serializable) {\n        return new Promise((resolve, reject) => {\n            this.process?.send(message, err => {\n                if (err) reject(err);\n                else resolve(this);\n            });\n        });\n    }\n}\n\nexport class ChildClient {\n    ipc: NodeJS.Process;\n    constructor() {\n        this.ipc = process;\n    }\n    public send(message: Serializable) {\n        const process = this.ipc;\n        return new Promise<void>((resolve, reject) => {\n            process.send?.(message, (err: Error) => {\n                if (err) reject(err);\n                else resolve();\n            });\n        });\n    }\n\n    public getData() {\n        return process.env;\n    }\n}\n","import { workerData } from 'worker_threads';\nexport function getInfo() {\n    const clusterMode = process.env.CLUSTER_MANAGER_MODE;\n    if (clusterMode !== 'worker' && clusterMode !== 'process')\n        throw new Error('NO CHILD/MASTER EXISTS OR SUPPLIED CLUSTER_MANAGER_MODE IS INCORRECT');\n\n    let data: ClusterClientData;\n\n    if (clusterMode === 'process') {\n        const shardList: number[] = [];\n        const parseShardList = process.env?.SHARD_LIST?.split(',') || [];\n        parseShardList.forEach(c => shardList.push(Number(c)));\n        data = {\n            SHARD_LIST: shardList,\n            TOTAL_SHARDS: Number(process.env.TOTAL_SHARDS),\n            CLUSTER_COUNT: Number(process.env.CLUSTER_COUNT),\n            CLUSTER: Number(process.env.CLUSTER),\n            CLUSTER_MANAGER_MODE: clusterMode,\n            MAINTENANCE: process.env.MAINTENANCE,\n            CLUSTER_QUEUE_MODE: process.env.CLUSTER_QUEUE_MODE,\n            FIRST_SHARD_ID: shardList[0] as number,\n            LAST_SHARD_ID: shardList[shardList.length - 1] as number,\n        };\n    } else {\n        data = workerData;\n        data.FIRST_SHARD_ID = data.SHARD_LIST[0] as number;\n        data.LAST_SHARD_ID = data.SHARD_LIST[data.SHARD_LIST.length - 1] as number;\n    }\n    return data;\n}\n\nexport interface ClusterClientData {\n    SHARD_LIST: number[];\n    TOTAL_SHARDS: number;\n    LAST_SHARD_ID: number;\n    FIRST_SHARD_ID: number;\n    CLUSTER_COUNT: number;\n    MAINTENANCE?: string;\n    CLUSTER_QUEUE_MODE?: 'auto' | string | undefined;\n    CLUSTER: number;\n    CLUSTER_MANAGER_MODE: ClusterManagerMode;\n}\n\nexport type ClusterManagerMode = 'process' | 'worker';\n","import { generateNonce } from '../Util/Util';\nimport { RawMessage } from './IPCMessage';\n\nexport interface StoredPromise {\n    resolve(value: any): void;\n    reject(error: Error): void;\n    options: PromiseCreateOptions;\n    timeout?: NodeJS.Timeout;\n}\n\nexport interface ResolveMessage {\n    _error: { message: string; stack: string; name: string };\n    _result: any;\n    _eval?: string;\n    _type?: number;\n    nonce: string;\n}\n\nexport interface PromiseCreateOptions {\n    timeout?: number;\n}\n\nexport class PromiseHandler {\n    nonce: Map<string, StoredPromise>;\n    constructor() {\n        this.nonce = new Map();\n    }\n    public resolve(message: ResolveMessage) {\n        const promise = this.nonce.get(message.nonce);\n        if (promise) {\n            if (promise.timeout) clearTimeout(promise.timeout);\n            this.nonce.delete(message.nonce);\n            if (message._error) {\n                const error = new Error(message._error.message);\n                error.stack = message._error.stack;\n                error.name = message._error.name;\n                promise.reject(error);\n            } else {\n                promise.resolve(message._result);\n            }\n        }\n    }\n\n    public async create(\n        message: RawMessage & { options?: PromiseCreateOptions; stack?: string },\n        options: PromiseCreateOptions,\n    ) {\n        if (!options) options = {};\n        if (Object.keys(options).length === 0 && message.options) options = message.options;\n        if (!message.nonce) message.nonce = generateNonce();\n        return await new Promise((resolve, reject) => {\n            if (options.timeout) {\n                const timeout = setTimeout(() => {\n                    this.nonce.delete(message.nonce as string);\n                    const error = new Error('Promise timed out');\n                    error.stack = message.stack || error.stack;\n                    reject(error);\n                }, options.timeout);\n                this.nonce.set(message.nonce as string, { resolve, reject, options, timeout });\n            } else this.nonce.set(message.nonce as string, { resolve, reject, options });\n        });\n    }\n}\n","import { IPCMessage, BaseMessage, RawMessage } from '../Structures/IPCMessage';\nimport {\n    Awaitable,\n    ClusterClientEvents,\n    evalOptions,\n    Events,\n    messageType,\n    Serialized,\n} from '../types/shared';\n\nimport { ClusterManager as Manager } from '../Core/ClusterManager';\n\nimport { getInfo } from '../Structures/Data';\n\nimport { WorkerClient } from '../Structures/Worker';\nimport { ChildClient } from '../Structures/Child';\nimport { ClusterClientHandler } from '../Structures/IPCHandler';\nimport { PromiseHandler } from '../Structures/PromiseHandler';\n\nimport EventEmitter from 'events';\nimport { Serializable } from 'child_process';\nimport { generateNonce } from '../Util/Util';\n///communicates between the master workers and the process\nexport class ClusterClient<DiscordClient> extends EventEmitter {\n    client: DiscordClient;\n    mode: 'process' | 'worker';\n    queue: { mode: 'auto' | string | undefined };\n    maintenance: string | undefined | Boolean;\n    ready: boolean;\n    process: ChildClient | WorkerClient | null;\n    messageHandler: any;\n    promise: PromiseHandler;\n    constructor(client: DiscordClient) {\n        super();\n        /**\n         * Client for the Cluster\n         */\n        this.client = client;\n\n        /**\n         * Mode the Cluster was spawned with\n         */\n        this.mode = this.info.CLUSTER_MANAGER_MODE;\n        const mode = this.mode;\n\n        /**\n         * If the Cluster is spawned automatically or with an own controller\n         */\n        this.queue = {\n            mode: this.info.CLUSTER_QUEUE_MODE,\n        };\n\n        /**\n         * If the Cluster is under maintenance\n         */\n        this.maintenance = this.info.MAINTENANCE;\n        if (this.maintenance === 'undefined') this.maintenance = false;\n        if (!this.maintenance) {\n            // Wait 100ms so listener can be added\n            setTimeout(() => this.triggerClusterReady(), 100);\n        }\n\n        this.ready = false;\n\n        this.process = null;\n\n        if (mode === 'process') this.process = new ChildClient();\n        else if (mode === 'worker') this.process = new WorkerClient();\n\n        this.messageHandler = new ClusterClientHandler<DiscordClient>(this, this.process);\n\n        this.promise = new PromiseHandler();\n\n        this.process?.ipc?.on('message', this._handleMessage.bind(this));\n\n        // @ts-ignore\n        client.on?.('ready', () => {\n            this.triggerReady();\n        });\n    }\n    /**\n     * cluster's id\n     */\n    public get id() {\n        return this.info.CLUSTER;\n    }\n    /**\n     * Array of shard IDs of this client\n     */\n    public get ids() {\n        // @ts-ignore\n        if (!this.client.ws) return this.info.SHARD_LIST;\n        // @ts-ignore\n        return this.client.ws.shards;\n    }\n    /**\n     * Total number of clusters\n     */\n    public get count() {\n        return this.info.CLUSTER_COUNT;\n    }\n    /**\n     * Gets some Info like Cluster_Count, Number, Total shards...\n     */\n    public get info() {\n        return getInfo();\n    }\n    /**\n     * Sends a message to the master process.\n     * @fires Cluster#message\n     */\n    public send(message: Serializable) {\n        if (typeof message === 'object') message = new BaseMessage(message).toJSON();\n        return this.process?.send(message);\n    }\n    /**\n     * Fetches a client property value of each cluster, or a given cluster.\n     * @example\n     * client.cluster.fetchClientValues('guilds.cache.size')\n     *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n     *   .catch(console.error);\n     * @see {@link ClusterManager#fetchClientValues}\n     */\n    public fetchClientValues(prop: string, cluster?: number) {\n        return this.broadcastEval(`this.${prop}`, { cluster });\n    }\n\n    /**\n     * Evaluates a script or function on the Cluster Manager\n     * @example\n     * client.cluster.evalOnManager('process.uptime')\n     *   .then(result => console.log(result))\n     *   .catch(console.error);\n     * @see {@link ClusterManager#evalOnManager}\n     */\n    public evalOnManager(script: string): Promise<any[]>;\n    public evalOnManager(script: string, options?: evalOptions): Promise<any>;\n    public evalOnManager<T>(fn: (manager: Manager) => T, options?: evalOptions): Promise<T>;\n    public evalOnManager<T>(fn: (manager: Manager) => T, options?: evalOptions): Promise<any[]>;\n    public async evalOnManager<T>(script: string | ((manager: Manager) => T), options?: evalOptions) {\n        const evalOptions = options || { _type: undefined };\n        evalOptions._type = messageType.CLIENT_MANAGER_EVAL_REQUEST;\n\n        return await this.broadcastEval(script as string, evalOptions);\n    }\n\n    /**\n     * Evaluates a script or function on all clusters, or a given cluster, in the context of the {@link Client}s.\n     * @example\n     * client.cluster.broadcastEval('this.guilds.cache.size')\n     *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n     *   .catch(console.error);\n     * @see {@link ClusterManager#broadcastEval}\n     */\n    public broadcastEval(script: string): Promise<any[]>;\n    public broadcastEval(script: string, options?: evalOptions): Promise<any>;\n    public broadcastEval<T>(fn: (client: DiscordClient) => Awaitable<T>): Promise<Serialized<T>[]>;\n    public broadcastEval<T>(\n        fn: (client: DiscordClient) => Awaitable<T>,\n        options?: { cluster?: number; timeout?: number },\n    ): Promise<Serialized<T>>;\n    public broadcastEval<T, P>(\n        fn: (client: DiscordClient, context: Serialized<P>) => Awaitable<T>,\n        options?: evalOptions<P>,\n    ): Promise<Serialized<T>[]>;\n    public broadcastEval<T, P>(\n        fn: (client: DiscordClient, context: Serialized<P>) => Awaitable<T>,\n        options?: evalOptions<P>,\n    ): Promise<Serialized<T>>;\n    public async broadcastEval<T, P>(\n        script:\n            | string\n            | ((client: DiscordClient, context?: Serialized<P>) => Awaitable<T> | Promise<Serialized<T>>),\n        options?: evalOptions | evalOptions<P>,\n    ) {\n        if (!script || (typeof script !== 'string' && typeof script !== 'function'))\n            throw new TypeError(\n                'Script for BroadcastEvaling has not been provided or must be a valid String/Function!',\n            );\n\n        const broadcastOptions = options || { context: undefined, _type: undefined, timeout: undefined };\n        script =\n            typeof script === 'function' ? `(${script})(this, ${JSON.stringify(broadcastOptions.context)})` : script;\n        const nonce = generateNonce();\n        const message = {\n            nonce,\n            _eval: script,\n            options,\n            _type: broadcastOptions._type || messageType.CLIENT_BROADCAST_REQUEST,\n        };\n        await this.send(message);\n\n        return await this.promise.create(message, broadcastOptions);\n    }\n    /**\n     * Sends a Request to the ParentCluster and returns the reply\n     * @example\n     * client.cluster.request({content: 'hello'})\n     *   .then(result => console.log(result)) //hi\n     *   .catch(console.error);\n     * @see {@link IPCMessage#reply}\n     */\n    public request(message: RawMessage) {\n        const rawMessage = message || { _type: undefined };\n        rawMessage._type = messageType.CUSTOM_REQUEST;\n        this.send(rawMessage);\n        return this.promise.create(rawMessage, {});\n    }\n\n    /**\n     * Requests a respawn of all clusters.\n     * @see {@link ClusterManager#respawnAll}\n     */\n    public respawnAll(options: { clusterDelay?: number; respawnDelay?: number; timeout?: number } = {}) {\n        return this.send({ _type: messageType.CLIENT_RESPAWN_ALL, options });\n    }\n\n    /**\n     * Handles an IPC message.\n     * @private\n     */\n    private async _handleMessage(message: RawMessage) {\n        if (!message) return;\n        const emit = await this.messageHandler.handleMessage(message);\n        if (!emit) return;\n        let emitMessage;\n        if (typeof message === 'object') emitMessage = new IPCMessage(this, message);\n        else emitMessage = message;\n        /**\n         * Emitted upon receiving a message from the parent process/worker.\n         * @event ClusterClient#message\n         * @param {*} message Message that was received\n         */\n        this.emit('message', emitMessage);\n    }\n\n    public async _eval(script: string) {\n        // @ts-ignore\n        if (this.client._eval) {\n            // @ts-ignore\n            return await this.client._eval(script);\n        }\n        // @ts-ignore\n        this.client._eval = function (_: string) {\n            return eval(_);\n        }.bind(this.client);\n        // @ts-ignore\n        return await this.client._eval(script);\n    }\n\n    /**\n     * Sends a message to the master process, emitting an error from the client upon failure.\n     */\n    public _respond(type: string, message: Serializable) {\n        this.send(message)?.catch(err => {\n            const error = { err, message: '' };\n\n            error.message = `Error when sending ${type} response to master process: ${err.message}`;\n            /**\n             * Emitted when the client encounters an error.\n             * @event Client#error\n             * @param {Error} error The error encountered\n             */\n            // @ts-ignore\n            this.client.emit?.(Events.ERROR, error);\n        });\n    }\n\n    // Hooks\n    public triggerReady() {\n        this.process?.send({ _type: messageType.CLIENT_READY });\n        this.ready = true;\n        return this.ready;\n    }\n\n    public triggerClusterReady() {\n        this.emit('ready', this);\n        return true;\n    }\n\n    /**\n     *\n     * @param maintenance Whether the cluster should opt in maintenance when a reason was provided or opt-out when no reason was provided.\n     * @param all Whether to target it on all clusters or just the current one.\n     * @returns The maintenance status of the cluster.\n     */\n    public triggerMaintenance(maintenance: string, all = false) {\n        let _type = messageType.CLIENT_MAINTENANCE;\n        if (all) _type = messageType.CLIENT_MAINTENANCE_ALL;\n        this.process?.send({ _type, maintenance });\n        this.maintenance = maintenance;\n        return this.maintenance;\n    }\n\n    /**\n     * Manually spawn the next cluster, when queue mode is on 'manual'\n     */\n    public spawnNextCluster() {\n        if (this.queue.mode === 'auto')\n            throw new Error('Next Cluster can just be spawned when the queue is not on auto mode.');\n        return this.process?.send({ _type: messageType.CLIENT_SPAWN_NEXT_CLUSTER });\n    }\n\n    /**\n     * gets the total Internal shard count and shard list.\n     */\n    public static getInfo() {\n        return getInfo();\n    }\n}\n\n// Credits for EventEmitter typings: https://github.com/discordjs/discord.js/blob/main/packages/rest/src/lib/RequestManager.ts#L159 | See attached license\nexport interface ClusterClient<DiscordClient> {\n    emit: (<K extends keyof ClusterClientEvents<DiscordClient>>(event: K, ...args: ClusterClientEvents<DiscordClient>[K]) => boolean) &\n        (<S extends string | symbol>(event: Exclude<S, keyof ClusterClientEvents<DiscordClient>>, ...args: any[]) => boolean);\n\n    off: (<K extends keyof ClusterClientEvents<DiscordClient>>(\n        event: K,\n        listener: (...args: ClusterClientEvents<DiscordClient>[K]) => void,\n    ) => this) &\n        (<S extends string | symbol>(\n            event: Exclude<S, keyof ClusterClientEvents<DiscordClient>>,\n            listener: (...args: any[]) => void,\n        ) => this);\n\n    on: (<K extends keyof ClusterClientEvents<DiscordClient>>(event: K, listener: (...args: ClusterClientEvents<DiscordClient>[K]) => void) => this) &\n        (<S extends string | symbol>(\n            event: Exclude<S, keyof ClusterClientEvents<DiscordClient>>,\n            listener: (...args: any[]) => void,\n        ) => this);\n\n    once: (<K extends keyof ClusterClientEvents<DiscordClient>>(\n        event: K,\n        listener: (...args: ClusterClientEvents<DiscordClient>[K]) => void,\n    ) => this) &\n        (<S extends string | symbol>(\n            event: Exclude<S, keyof ClusterClientEvents<DiscordClient>>,\n            listener: (...args: any[]) => void,\n        ) => this);\n\n    removeAllListeners: (<K extends keyof ClusterClientEvents<DiscordClient>>(event?: K) => this) &\n        (<S extends string | symbol>(event?: Exclude<S, keyof ClusterClientEvents<DiscordClient>>) => this);\n}\n","import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport EventEmitter from 'events';\n\nimport { chunkArray, delayFor, fetchRecommendedShards, makePlainError, shardIdForGuildId } from '../Util/Util';\nimport { Queue } from '../Structures/Queue';\nimport { Cluster } from './Cluster';\nimport { PromiseHandler } from '../Structures/PromiseHandler';\nimport {\n    Awaitable,\n    ClusterManagerEvents,\n    ClusterManagerOptions,\n    ClusterManagerSpawnOptions,\n    ClusterRestartOptions,\n    DjsDiscordClient,\n    evalOptions,\n    Plugin,\n    QueueOptions,\n    Serialized,\n} from '../types/shared';\nimport { ChildProcessOptions } from '../Structures/Child';\nimport { WorkerThreadOptions } from '../Structures/Worker';\nimport { BaseMessage } from '../Structures/IPCMessage';\nimport { HeartbeatManager } from '../Plugins/HeartbeatSystem';\nimport { ReClusterManager } from '../Plugins/ReCluster';\n\nexport class ClusterManager extends EventEmitter {\n    /**\n     * Whether clusters should automatically respawn upon exiting\n     */\n    respawn: boolean;\n\n    /**\n     * How many times a cluster can maximally restart in the given interval\n     */\n    restarts: ClusterRestartOptions;\n\n    /**\n     * Data, which is passed to the workerData or the processEnv\n     */\n    clusterData: object;\n\n    /**\n     * Options, which is passed when forking a child or creating a thread\n     */\n    clusterOptions: ChildProcessOptions | WorkerThreadOptions | {};\n\n    /**\n     * Path to the bot script file\n     */\n    file: string;\n    /**\n     * Amount of internal shards in total\n     */\n    totalShards: number | -1;\n\n    /**\n     * Amount of total clusters to spawn\n     */\n    totalClusters: number | -1;\n\n    /**\n     * Amount of Shards per Clusters\n     */\n    shardsPerClusters: number | undefined;\n\n    /** Mode for Clusters to spawn with */\n    mode: 'worker' | 'process';\n\n    /**\n     * An array of arguments to pass to clusters (only when {@link ClusterManager#mode} is `process`)\n     */\n    shardArgs: string[];\n\n    /**\n     * An array of arguments to pass to the executable (only when {@link ClusterManager#mode} is `process`)\n     */\n    execArgv: string[];\n\n    /**\n     * List of internal shard ids this cluster manager spawns\n     */\n    shardList: number[];\n\n    /**\n     * Token to use for obtaining the automatic internal shards count, and passing to bot script\n     */\n    token: string | null;\n\n    /**\n     * A collection of all clusters the manager spawned\n     */\n    clusters: Map<number, Cluster>;\n    shardClusterList: number[][];\n\n    /**\n     * An Array of IDS[Number], which should be assigned to the spawned Clusters\n     */\n    clusterList: number[];\n    spawnOptions: ClusterManagerSpawnOptions;\n    queue: Queue;\n    promise: PromiseHandler;\n\n    /** HeartbeatManager Plugin */\n    heartbeat?: HeartbeatManager;\n    /** Reclustering Plugin */\n    recluster?: ReClusterManager;\n    constructor(file: string, options: ClusterManagerOptions) {\n        super();\n        if (!options) options = {};\n\n        if (options.keepAlive)\n            throw new Error(\n                'keepAlive is not supported anymore on and above v1.6.0. Import it as plugin (\"HeartbeatManager\"), therefore check the libs readme',\n            );\n\n        this.respawn = options.respawn ?? true;\n\n        this.restarts = options.restarts || { max: 3, interval: 60000 * 60, current: 0 };\n\n        this.clusterData = options.clusterData || {};\n\n        this.clusterOptions = options.clusterOptions || {};\n\n        this.file = file;\n        if (!file) throw new Error('CLIENT_INVALID_OPTION | No File specified.');\n        if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n        const stats = fs.statSync(this.file);\n        if (!stats.isFile()) throw new Error('CLIENT_INVALID_OPTION | Provided is file is not type of file');\n\n        this.totalShards = options.totalShards === 'auto' ? -1 : options.totalShards ?? -1;\n        if (this.totalShards !== -1) {\n            if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n                throw new TypeError('CLIENT_INVALID_OPTION | Amount of internal shards must be a number.');\n            }\n            if (this.totalShards < 1)\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of internal shards must be at least 1.');\n            if (!Number.isInteger(this.totalShards)) {\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of internal shards must be an integer.');\n            }\n        }\n\n        this.totalClusters = options.totalClusters === 'auto' ? -1 : options.totalClusters ?? -1;\n        if (this.totalClusters !== -1) {\n            if (typeof this.totalClusters !== 'number' || isNaN(this.totalClusters)) {\n                throw new TypeError('CLIENT_INVALID_OPTION | Amount of Clusters must be a number.');\n            }\n            if (this.totalClusters < 1)\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Clusters must be at least 1.');\n            if (!Number.isInteger(this.totalClusters)) {\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Clusters must be an integer.');\n            }\n        }\n\n        this.shardsPerClusters = options.shardsPerClusters;\n        if (this.shardsPerClusters) {\n            if (typeof this.shardsPerClusters !== 'number' || isNaN(this.shardsPerClusters)) {\n                throw new TypeError('CLIENT_INVALID_OPTION | Amount of ShardsPerClusters must be a number.');\n            }\n            if (this.shardsPerClusters < 1)\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of shardsPerClusters must be at least 1.');\n            if (!Number.isInteger(this.shardsPerClusters)) {\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Shards Per Clusters must be an integer.');\n            }\n        }\n\n        this.mode = options.mode || 'process';\n        if (this.mode !== 'worker' && this.mode !== 'process') {\n            throw new RangeError('CLIENT_INVALID_OPTION' + 'Cluster mode must be ' + '\"worker\" or \"process\"');\n        }\n\n        this.shardArgs = options.shardArgs ?? [];\n\n        this.execArgv = options.execArgv ?? [];\n\n        this.shardList = options.shardList ?? [];\n        if (this.shardList.length) {\n            if (!Array.isArray(this.shardList)) {\n                throw new TypeError('CLIENT_INVALID_OPTION | shardList must be an array.');\n            }\n            this.shardList = Array.from(new Set(this.shardList));\n            if (this.shardList.length < 1)\n                throw new RangeError('CLIENT_INVALID_OPTION | shardList must contain at least 1 ID.');\n            if (\n                this.shardList.some(\n                    shardID =>\n                        typeof shardID !== 'number' || isNaN(shardID) || !Number.isInteger(shardID) || shardID < 0,\n                )\n            ) {\n                throw new TypeError('CLIENT_INVALID_OPTION | shardList has to contain an array of positive integers.');\n            }\n        }\n\n        if (!options.token) options.token = process.env.DISCORD_TOKEN;\n\n        this.token = options.token ? options.token.replace(/^Bot\\s*/i, '') : null;\n\n        this.clusters = new Map();\n        this.shardClusterList = [];\n        process.env.SHARD_LIST = undefined;\n        process.env.TOTAL_SHARDS = this.totalShards as any;\n        process.env.CLUSTER = undefined;\n        process.env.CLUSTER_COUNT = this.totalClusters as any;\n        process.env.CLUSTER_MANAGER = 'true';\n        process.env.CLUSTER_MANAGER_MODE = this.mode;\n        process.env.DISCORD_TOKEN = String(this.token);\n        process.env.MAINTENANCE = undefined;\n\n        if (options.queue?.auto) process.env.CLUSTER_QUEUE_MODE = 'auto';\n        else process.env.CLUSTER_QUEUE_MODE = 'manual';\n\n        this.clusterList = options.clusterList || [];\n\n        this.spawnOptions = options.spawnOptions || { delay: 7000, timeout: -1 };\n        if (!this.spawnOptions.delay) this.spawnOptions.delay = 7000;\n\n        if (!options.queue) options.queue = { auto: true };\n        if (!options.queue.timeout) options.queue.timeout = this.spawnOptions.delay;\n        this.queue = new Queue(options.queue as Required<QueueOptions>);\n\n        this._debug(`[START] Cluster Manager has been initialized`);\n\n        this.promise = new PromiseHandler();\n    }\n\n    /**\n     * Spawns multiple internal shards.\n     */\n    public async spawn({ amount = this.totalShards, delay = 7000, timeout = -1 } = this.spawnOptions) {\n        if (delay < 7000) {\n            process.emitWarning(\n                `Spawn Delay (delay: ${delay}) is smaller than 7s, this can cause global rate limits on /gateway/bot`,\n                {\n                    code: 'CLUSTER_MANAGER',\n                },\n            );\n        }\n\n        if (amount === -1 || amount === 'auto') {\n            if (!this.token) throw new Error('A Token must be provided, when totalShards is set on auto.');\n            amount = await fetchRecommendedShards(this.token, 1000);\n            this.totalShards = amount as number;\n            this._debug(`Discord recommended a total shard count of ${amount}`);\n        } else {\n            if (typeof amount !== 'number' || isNaN(amount)) {\n                throw new TypeError('CLIENT_INVALID_OPTION | Amount of Internal Shards must be a number.');\n            }\n            if (amount < 1)\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Internal Shards must be at least 1.');\n            if (!Number.isInteger(amount)) {\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Internal Shards must be an integer.');\n            }\n        }\n        let clusterAmount = this.totalClusters;\n        if (clusterAmount === -1) {\n            clusterAmount = os.cpus().length;\n            this.totalClusters = clusterAmount;\n        } else {\n            if (typeof clusterAmount !== 'number' || isNaN(clusterAmount)) {\n                throw new TypeError('CLIENT_INVALID_OPTION | Amount of Clusters must be a number.');\n            }\n            if (clusterAmount < 1)\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Clusters must be at least 1.');\n            if (!Number.isInteger(clusterAmount)) {\n                throw new RangeError('CLIENT_INVALID_OPTION | Amount of Clusters must be an integer.');\n            }\n        }\n\n        if (!this.shardList.length) this.shardList = Array.from(Array(amount).keys());\n\n        //Calculate Shards per Cluster:\n        if (this.shardsPerClusters) this.totalClusters = Math.ceil(this.shardList.length / this.shardsPerClusters);\n\n        this.shardClusterList = chunkArray(\n            this.shardList,\n            (!isNaN(this.shardsPerClusters as any) ? this.shardsPerClusters as number : Math.ceil(this.shardList.length / (this.totalClusters as number))),\n        );\n\n        if (this.shardClusterList.length !== this.totalClusters) {\n            this.totalClusters = this.shardClusterList.length;\n        }\n        if (this.shardList.some(shardID => shardID >= Number(amount))) {\n            throw new RangeError('CLIENT_INVALID_OPTION | Shard IDs must be smaller than the amount of shards.');\n        }\n\n        // Update spawn options\n        this.spawnOptions = { delay, timeout };\n\n\n\n        this._debug(`[Spawning Clusters]\n    ClusterCount: ${this.totalClusters}\n    ShardCount: ${amount}\n    ShardList: ${this.shardClusterList.join(', ')}`);\n        for (let i = 0; i < this.totalClusters; i++) {\n            const clusterId = this.clusterList[i] || i;\n            if (this.shardClusterList[i]) {\n                const length = this.shardClusterList[i]?.length as number;\n                const readyTimeout = timeout !== -1 ? timeout + delay * length : timeout;\n                const spawnDelay = delay * length;\n                this.queue.add({\n                    run: (...a) => {\n                        const cluster = this.createCluster(\n                            clusterId,\n                            this.shardClusterList[i] as number[],\n                            this.totalShards,\n                        );\n                        return cluster.spawn(...a);\n                    },\n                    args: [readyTimeout],\n                    timeout: spawnDelay,\n                });\n            }\n        }\n        return this.queue.start();\n    }\n\n    /**\n     * Sends a message to all clusters.\n     */\n    public broadcast(message: BaseMessage) {\n        const promises = [];\n        for (const cluster of Array.from(this.clusters.values())) promises.push(cluster.send(message));\n        return Promise.all(promises);\n    }\n    /**\n     * Creates a single cluster.\n     * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n     * <info>This is usually not necessary to manually specify.</info>\n     * @returns Note that the created cluster needs to be explicitly spawned using its spawn method.\n     */\n    public createCluster(id: number, shardsToSpawn: number[], totalShards: number, recluster = false) {\n        const cluster = new Cluster(this, id, shardsToSpawn, totalShards);\n        if (!recluster) this.clusters.set(id, cluster);\n        /**\n         * Emitted upon creating a cluster.\n         * @event ClusterManager#clusterCreate\n         * @param {Cluster} cluster Cluster that was created\n         */\n        // @todo clusterReady event\n        this.emit('clusterCreate', cluster);\n\n        this._debug(`[CREATE] Created Cluster ${cluster.id}`);\n        return cluster;\n    }\n    /**\n     * Evaluates a script on all clusters, or a given cluster, in the context of the {@link Client}s.\n     * @returns Results of the script execution\n     */\n    public broadcastEval(script: string): Promise<any[]>;\n    public broadcastEval(script: string, options?: evalOptions): Promise<any>;\n    public broadcastEval<T>(fn: (client: DjsDiscordClient) => Awaitable<T>): Promise<Serialized<T>[]>;\n    public broadcastEval<T>(\n        fn: (client: DjsDiscordClient) => Awaitable<T>,\n        options?: { cluster?: number; timeout?: number },\n    ): Promise<Serialized<T>>;\n    public broadcastEval<T, P>(\n        fn: (client: DjsDiscordClient, context: Serialized<P>) => Awaitable<T>,\n        options?: evalOptions<P>,\n    ): Promise<Serialized<T>[]>;\n    public broadcastEval<T, P>(\n        fn: (client: DjsDiscordClient, context: Serialized<P>) => Awaitable<T>,\n        options?: evalOptions<P>,\n    ): Promise<Serialized<T>>;\n    public async broadcastEval<T, P>(\n        script:\n            | string\n            | ((client: DjsDiscordClient, context?: Serialized<P>) => Awaitable<T> | Promise<Serialized<T>>),\n        evalOptions?: evalOptions | evalOptions<P>,\n    ) {\n        const options = evalOptions ?? {};\n        if (!script || (typeof script !== 'string' && typeof script !== 'function'))\n            return Promise.reject(new TypeError('ClUSTERING_INVALID_EVAL_BROADCAST'));\n        script = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(options.context)})` : script;\n\n        if (Object.prototype.hasOwnProperty.call(options, 'cluster')) {\n            if (typeof options.cluster === 'number') {\n                if (options.cluster < 0) throw new RangeError('CLUSTER_ID_OUT_OF_RANGE');\n            }\n            if (Array.isArray(options.cluster)) {\n                if (options.cluster.length === 0) throw new RangeError('ARRAY_MUST_CONTAIN_ONE CLUSTER_ID');\n            }\n        }\n        if (options.guildId) {\n            options.shard = shardIdForGuildId(options.guildId, this.totalShards);\n        }\n        if (options.shard) {\n            if (typeof options.shard === 'number') {\n                if (options.shard < 0) throw new RangeError('SHARD_ID_OUT_OF_RANGE');\n            }\n            if (Array.isArray(options.shard)) {\n                // @todo Support Array of Shards\n                if (options.shard.length === 0) throw new RangeError('ARRAY_MUST_CONTAIN_ONE SHARD_ID');\n            }\n            options.cluster = Array.from(this.clusters.values()).find(c =>\n                c.shardList.includes(options.shard as number),\n            )?.id;\n        }\n        return this._performOnClusters('eval', [script], options.cluster, options.timeout);\n    }\n    /**\n     * Fetches a client property value of each cluster, or a given cluster.\n     * @param prop Name of the client property to get, using periods for nesting\n     * @param cluster Cluster to fetch property from, all if undefined\n     * @example\n     * manager.fetchClientValues('guilds.cache.size')\n     *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n     *   .catch(console.error);\n     */\n    public fetchClientValues(prop: string, cluster?: number) {\n        return this.broadcastEval(`this.${prop}`, { cluster });\n    }\n\n    /**\n     * Runs a method with given arguments on all clusters, or a given cluster.\n     * @param method Method name to run on each cluster\n     * @param args Arguments to pass through to the method call\n     * @param cluster cluster to run on, all if undefined\n     * @param timeout the amount of time to wait until the promise will be rejected\n     * @returns Results of the method execution\n     * @private\n     */\n    private _performOnClusters(method: 'eval', args: any[], cluster?: number | number[], timeout?: number) {\n        if (this.clusters.size === 0) return Promise.reject(new Error('CLUSTERING_NO_CLUSTERS'));\n\n        if (typeof cluster === 'number') {\n            if (this.clusters.has(cluster))\n                return (\n                    this.clusters\n                        .get(cluster)\n                        // @ts-expect-error\n                        ?.[method](...args, undefined, timeout)\n                        .then((e: any) => [e])\n                );\n            return Promise.reject(new Error('CLUSTERING_CLUSTER_NOT_FOUND FOR ClusterId: ' + cluster));\n        }\n        let clusters = Array.from(this.clusters.values());\n        if (cluster) clusters = clusters.filter(c => cluster.includes(c.id));\n        if (clusters.length === 0) return Promise.reject(new Error('CLUSTERING_NO_CLUSTERS_FOUND'));\n\n        /* if (this.clusters.size !== this.totalClusters && !cluster) return Promise.reject(new Error('CLUSTERING_IN_PROCESS')); */\n\n        const promises = [];\n\n        // @ts-expect-error\n        for (const cl of clusters) promises.push(cl[method](...args, undefined, timeout));\n        return Promise.all(promises);\n    }\n\n    /**\n     * Kills all running clusters and respawns them.\n     * @param options Options for respawning shards\n     */\n    public async respawnAll({ clusterDelay = this.spawnOptions.delay = 5500, respawnDelay = this.spawnOptions.delay = 5500, timeout = -1 } = {}) {\n        this.promise.nonce.clear();\n        let s = 0;\n        let i = 0;\n        this._debug('Respawning all Clusters');\n        for (const cluster of Array.from(this.clusters.values())) {\n            const promises: any[] = [cluster.respawn({ delay: respawnDelay, timeout })];\n            const length = this.shardClusterList[i]?.length || this.totalShards / this.totalClusters;\n            if (++s < this.clusters.size && clusterDelay > 0) promises.push(delayFor(length * clusterDelay));\n            i++;\n            await Promise.all(promises); // eslint-disable-line no-await-in-loop\n        }\n        return this.clusters;\n    }\n\n    //Custom Functions:\n\n    /**\n     * Runs a method with given arguments on the Manager itself\n     */\n    public async evalOnManager(script: string) {\n        script = typeof script === 'function' ? `(${script})(this)` : script;\n        let result;\n        let error;\n        try {\n            result = await eval(script);\n        } catch (err) {\n            error = err;\n        }\n        return { _result: result, _error: error ? makePlainError(error) : null };\n    }\n\n    /**\n     * Runs a method with given arguments on the provided Cluster Client\n     * @returns Results of the script execution\n     * @private\n     */\n    public evalOnCluster(script: string, options: evalOptions) {\n        return this.broadcastEval(script, options)?.then((r: any[]) => r[0]);\n    }\n\n    /**\n     * Adds a plugin to the cluster manager\n     */\n    public extend(...plugins: Plugin[]) {\n        if (!plugins) throw new Error('NO_PLUGINS_PROVIDED');\n        if (!Array.isArray(plugins)) plugins = [plugins];\n        for (const plugin of plugins) {\n            if (!plugin) throw new Error('PLUGIN_NOT_PROVIDED');\n            if (typeof plugin !== 'object') throw new Error('PLUGIN_NOT_A_OBJECT');\n            plugin.build(this);\n        }\n    }\n\n    /**\n     * @param reason If maintenance should be enabled on all clusters with a given reason or disabled when nonce provided\n     */\n    triggerMaintenance(reason: string) {\n        return Array.from(this.clusters.values()).forEach(cluster => cluster.triggerMaintenance(reason));\n    }\n    /**\n     * Logs out the Debug Messages\n     * <warn>Using this method just emits the Debug Event.</warn>\n     * <info>This is usually not necessary to manually specify.</info>\n     */\n    public _debug(message: string, cluster?: number) {\n        let log;\n        if (cluster === undefined) {\n            log = `[CM => Manager] ` + message;\n        } else {\n            log = `[CM => Cluster ${cluster}] ` + message;\n        }\n        /**\n         * Emitted upon receiving a message\n         * @event ClusterManager#debug\n         * @param {string} Message, which was received\n         */\n        this.emit('debug', log);\n        return log;\n    }\n}\n\n// Credits for EventEmitter typings: https://github.com/discordjs/discord.js/blob/main/packages/rest/src/lib/RequestManager.ts#L159 | See attached license\nexport interface ClusterManager {\n    emit: (<K extends keyof ClusterManagerEvents>(event: K, ...args: ClusterManagerEvents[K]) => boolean) &\n    (<S extends string | symbol>(event: Exclude<S, keyof ClusterManagerEvents>, ...args: any[]) => boolean);\n\n    off: (<K extends keyof ClusterManagerEvents>(\n        event: K,\n        listener: (...args: ClusterManagerEvents[K]) => void,\n    ) => this) &\n    (<S extends string | symbol>(\n        event: Exclude<S, keyof ClusterManagerEvents>,\n        listener: (...args: any[]) => void,\n    ) => this);\n\n    on: (<K extends keyof ClusterManagerEvents>(\n        event: K,\n        listener: (...args: ClusterManagerEvents[K]) => void,\n    ) => this) &\n    (<S extends string | symbol>(\n        event: Exclude<S, keyof ClusterManagerEvents>,\n        listener: (...args: any[]) => void,\n    ) => this);\n\n    once: (<K extends keyof ClusterManagerEvents>(\n        event: K,\n        listener: (...args: ClusterManagerEvents[K]) => void,\n    ) => this) &\n    (<S extends string | symbol>(\n        event: Exclude<S, keyof ClusterManagerEvents>,\n        listener: (...args: any[]) => void,\n    ) => this);\n\n    removeAllListeners: (<K extends keyof ClusterManagerEvents>(event?: K) => this) &\n    (<S extends string | symbol>(event?: Exclude<S, keyof ClusterManagerEvents>) => this);\n}\n","import { QueueOptions } from '../types/shared';\nimport { delayFor } from '../Util/Util';\n\nexport interface QueueItem {\n    run(...args: any): Promise<any>;\n    args: any[];\n    time?: number;\n    timeout: number;\n}\n\nexport class Queue {\n    queue: QueueItem[];\n    options: Required<QueueOptions>;\n    paused: boolean;\n    constructor(options: Required<QueueOptions>) {\n        this.options = options;\n        this.queue = [];\n        this.paused = false;\n    }\n\n    /**\n     * Starts the queue and run's the item functions\n     */\n    public async start() {\n        if (!this.options.auto) {\n            return new Promise(resolve => {\n                const interval = setInterval(() => {\n                    if (this.queue.length === 0) {\n                        clearInterval(interval);\n                        resolve('Queue finished');\n                    }\n                }, 200);\n            });\n        }\n\n        const length = this.queue.length;\n        for (let i = 0; i < length; i++) {\n            if (!this.queue[0]) continue;\n            const timeout = this.queue[0].timeout;\n            await this.next();\n            await delayFor(timeout);\n        }\n        return this;\n    }\n\n    /**\n     * Goes to the next item in the queue\n     */\n    public async next() {\n        if (this.paused) return;\n        const item = this.queue.shift();\n        if (!item) return true;\n        return item.run(...item.args);\n    }\n\n    /**\n     * Stop's the queue and blocks the next item from running\n     */\n    public stop() {\n        this.paused = true;\n        return this;\n    }\n\n    /**\n     * Resume's the queue\n     */\n    public resume() {\n        this.paused = false;\n        return this;\n    }\n\n    /**\n     * Adds an item to the queue\n     */\n    public add(item: QueueItem) {\n        this.queue.push({\n            run: item.run,\n            args: item.args,\n            time: Date.now(),\n            timeout: item.timeout ?? this.options.timeout,\n        });\n        return this;\n    }\n}\n","import { Cluster } from '../Core/Cluster';\nimport { ClusterManager } from '../Core/ClusterManager';\nimport { messageType } from '../types/shared';\n\nexport type keepAliveOptions = {\n    /** Default interval is 20000 */\n    interval?: number;\n    /** Default maxMissedHeartbeats is 5 */\n    maxMissedHeartbeats?: number;\n};\n\nexport class HeartbeatManager {\n    options: keepAliveOptions;\n    clusters: Map<number, Heartbeat>;\n    manager: null | ClusterManager;\n    name: 'heartbeat';\n    constructor(options?: keepAliveOptions) {\n        if (!options) options = {};\n        this.options = options;\n\n        if (!this.options.interval) this.options.interval = 20000;\n        if (!this.options.maxMissedHeartbeats) this.options.maxMissedHeartbeats = 5;\n        this.clusters = new Map();\n        this.manager = null;\n        this.name = 'heartbeat';\n    }\n    public build(manager: ClusterManager) {\n        manager[this.name] = this;\n        this.manager = manager;\n        this.start();\n    }\n    public start() {\n        this.manager?.on('clusterReady', (cluster: Cluster) => {\n            if (this.clusters.has(cluster.id)) this.clusters.get(cluster.id)?.stop();\n            this.clusters.set(cluster.id, new Heartbeat(this, cluster, this.options as Required<keepAliveOptions>));\n        });\n    }\n    public stop(cluster: Cluster, reason: string) {\n        if (!this.clusters.has(cluster.id)) return;\n        this.clusters.get(cluster.id)?.stop();\n        this.manager?._debug(`[Heartbeat_MISSING] ${reason}`, cluster.id);\n        if (cluster.restarts.current < cluster.restarts.max) {\n            cluster.respawn(this.manager?.spawnOptions);\n            this.manager?._debug('[Heartbeat_MISSING] Attempted Respawn', cluster.id);\n        } else {\n            this.manager?._debug('[Heartbeat_MISSING] Respawn Rejected | Max Restarts of Cluster Reached', cluster.id);\n        }\n    }\n    public ack(id: number, date: number) {\n        if (!this.clusters.has(id)) return;\n        this.clusters.get(id)?.ack(date);\n    }\n}\n\nexport class Heartbeat {\n    manager: HeartbeatManager;\n    options: Required<keepAliveOptions>;\n    interval?: NodeJS.Timer;\n    heartbeats: Map<number, Boolean>;\n    instance: Cluster;\n    constructor(manager: HeartbeatManager, instance: Cluster, options: Required<keepAliveOptions>) {\n        this.manager = manager;\n        this.options = options;\n        this.interval = undefined;\n        this.heartbeats = new Map();\n        this.instance = instance;\n        this.start();\n    }\n\n    public ack(date: number) {\n        return this.heartbeats.delete(date);\n    }\n\n    public start() {\n        return (this.interval = setInterval(() => {\n            const start = Date.now();\n            this.heartbeats.set(start, true);\n            this.instance.send({ _type: messageType.HEARTBEAT, date: start })?.catch(() => null);\n            if (this.heartbeats.size > this.options.maxMissedHeartbeats) {\n                this.manager.stop(this.instance, `Missed ${this.heartbeats.size} Heartbeat Acks | Attempting Respawn`);\n            }\n        }, this.options.interval));\n    }\n\n    public stop() {\n        this.heartbeats.clear();\n        clearInterval(this.interval);\n    }\n\n    public resume() {\n        this.start();\n    }\n}\n","import { Cluster } from '../Core/Cluster';\nimport { ClusterManager } from '../Core/ClusterManager';\nimport { chunkArray, fetchRecommendedShards } from '../Util/Util';\n\nexport type ReClusterRestartMode = 'gracefulSwitch' | 'rolling';\n\nexport interface ReClusterOptions {\n    /** The delay to wait between each cluster spawn */\n    delay?: number;\n    /** The readyTimeout to wait until the cluster spawn promise is rejected*/\n    timeout?: number;\n    /** The new totalShards of the bot*/\n    totalShards?: number | 'auto';\n    /** The amount of totalClusters to spread the shards over all clusters */\n    totalClusters?: number;\n    /** The amount of shards per cluster */\n    shardsPerClusters?: number;\n    /** The shardList chunked over the clusters */\n    shardList?: number[];\n    /** The new shardList of the Cluster Manager */\n    shardClusterList?: number[][];\n    /** The restartMode of the clusterManager, gracefulSwitch = waits until all new clusters have spawned with maintenance mode, rolling = Once the Cluster is Ready, the old cluster will be killed*/\n    restartMode?: ReClusterRestartMode;\n}\n\nexport class ReClusterManager {\n    options: ReClusterOptions;\n    name: 'recluster';\n    onProgress: Boolean;\n    manager?: ClusterManager;\n    constructor(options?: ReClusterOptions) {\n        if (!options) this.options = {};\n        else this.options = options;\n        this.name = 'recluster';\n        this.onProgress = false;\n    }\n    build(manager: ClusterManager) {\n        manager[this.name] = this;\n        this.manager = manager;\n        return this;\n    }\n\n    /**\n     * Execute a Zero Downtime Restart on all Clusters with an updated totalShards (count) or a scheduled restart.\n     * @param options\n     * @param options.delay\n     * @param options.timeout\n     * @param options.totalShards\n     * @param options.totalClusters\n     * @param options.shardsPerClusters\n     * @param options.shardClusterList\n     * @param options.shardList\n     * @param options.restartMode\n     */\n    public async start(options?: ReClusterOptions) {\n        let {\n            delay,\n            timeout,\n            totalClusters,\n            totalShards,\n            shardsPerClusters,\n            shardClusterList,\n            shardList = this.manager?.shardList,\n            restartMode = 'gracefulSwitch',\n        } = options || { restartMode: 'gracefulSwitch' };\n        if (this.onProgress) throw new Error('Zero Downtime Reclustering is already in progress');\n        if (!this.manager) throw new Error('Manager is missing on ReClusterManager');\n        if (totalShards) {\n            if (!this.manager?.token)\n                throw new Error('Token must be defined on manager, when totalShards is set on auto');\n            if (totalShards === 'auto' || totalShards === -1)\n                totalShards = await fetchRecommendedShards(this.manager.token);\n            this.manager.totalShards = totalShards as number;\n        }\n        if (totalClusters) this.manager.totalClusters = totalClusters;\n        if (shardsPerClusters) {\n            this.manager.shardsPerClusters = shardsPerClusters;\n            this.manager.totalClusters = Math.ceil(this.manager.totalShards / this.manager.shardsPerClusters);\n        }\n\n        if (shardList) this.manager.shardList = shardList;\n        else this.manager.shardList = Array.from(Array(this.manager.totalShards).keys());\n        if (shardClusterList) this.manager.shardClusterList = shardClusterList;\n        else\n            this.manager.shardClusterList = chunkArray(\n                this.manager.shardList,\n                Math.ceil(this.manager.shardList.length / this.manager.totalClusters),\n            );\n\n        if (this.manager.shardClusterList.length !== this.manager.totalClusters) {\n            this.manager.totalClusters = this.manager.shardClusterList.length;\n        }\n        this.manager._debug(\n            [\n                '[↻][ReClustering] Starting... Zerodowntime Reclustering',\n                `├── Mode: ${restartMode}`,\n                `├── Total Shards: ${this.manager.totalShards}`,\n                `├── Total Clusters: ${this.manager.totalClusters}`,\n                `├── Shards Per Cluster: ${this.manager.shardsPerClusters}`,\n                `├── Shard Cluster List: ${this.manager.shardClusterList.join(', ')}`,\n                `└── Shard List: ${this.manager.shardList.join(', ')}`,\n            ].join('\\n'),\n        );\n        return this._start({ restartMode, timeout, delay });\n    }\n\n    /**\n     * @param options\n     * @param options.delay The delay to wait between each cluster spawn\n     * @param options.timeout The readyTimeout to wait until the cluster spawn promise is rejected\n     * @param options.restartMode The restartMode of the clusterManager, gracefulSwitch = waits until all new clusters have spawned with maintenance mode, rolling = Once the Cluster is Ready, the old cluster will be killed\n     */\n    public async _start({ restartMode = 'gracefulSwitch', timeout = 30000 * 6, delay = 7000 }) {\n        if (!this.manager) throw new Error('Manager is missing on ReClusterManager');\n        process.env.MAINTENANCE = 'recluster';\n        this.manager.triggerMaintenance('recluster');\n        this.manager._debug('[↻][ReClustering] Enabling Maintenance Mode on all clusters');\n\n        let switchClusterAfterReady = false;\n        // when no shard settings have been updated\n        switchClusterAfterReady = restartMode === 'rolling'; //gracefulSwitch, spawn all clusters and kill all old clusters, when new clusters are ready\n\n        const newClusters: Map<number, Cluster> = new Map();\n        const oldClusters: Map<number, Cluster> = new Map();\n        Array.from(this.manager.clusters.values()).forEach(cluster => {\n            oldClusters.set(cluster.id, cluster);\n        });\n        for (let i = 0; i < this.manager.totalClusters; i++) {\n            const length =\n                this.manager.shardClusterList[i]?.length || this.manager.totalShards / this.manager.totalClusters;\n            const clusterId = this.manager.clusterList[i] || i;\n            const readyTimeout = timeout !== -1 ? timeout + delay * length : timeout;\n            const spawnDelay = delay * length;\n            this.manager.queue.add({\n                run: (...a) => {\n                    if (!this.manager) throw new Error('Manager is missing on ReClusterManager');\n                    const cluster = this.manager.createCluster(\n                        clusterId,\n                        this.manager.shardClusterList[i] as number[],\n                        this.manager.totalShards,\n                        true,\n                    );\n                    newClusters.set(clusterId, cluster);\n                    this.manager._debug(`[↻][ReClustering][${clusterId}] Spawning... Cluster`);\n                    return cluster.spawn(...a).then(c => {\n                        if (!this.manager) throw new Error('Manager is missing on ReClusterManager');\n                        this.manager._debug(`[↻][ReClustering][${clusterId}] Cluster Ready`);\n                        if (switchClusterAfterReady) {\n                            const oldCluster = this.manager.clusters.get(clusterId);\n                            if (oldCluster) {\n                                oldCluster.kill({ force: true, reason: 'reclustering' });\n                                oldClusters.delete(clusterId);\n                            }\n                            this.manager.clusters.set(clusterId, cluster);\n                            cluster.triggerMaintenance(undefined);\n                            this.manager._debug(\n                                `[↻][ReClustering][${clusterId}] Switched OldCluster to NewCluster and exited Maintenance Mode`,\n                            );\n                        }\n                        return c;\n                    });\n                },\n                args: [readyTimeout],\n                timeout: spawnDelay,\n            });\n        }\n        await this.manager.queue.start();\n        if (oldClusters.size) {\n            this.manager._debug('[↻][ReClustering] Killing old clusters');\n            for (const [id, cluster] of Array.from(oldClusters)) {\n                cluster.kill({ force: true, reason: 'reclustering' });\n                this.manager._debug(`[↻][ReClustering][${id}] Killed OldCluster`);\n                this.manager.clusters.delete(id);\n            }\n            oldClusters.clear();\n        }\n        if (!switchClusterAfterReady) {\n            this.manager._debug(\n                '[↻][ReClustering] Starting exiting Maintenance Mode on all clusters and killing old clusters',\n            );\n            for (let i = 0; i < this.manager.totalClusters; i++) {\n                const clusterId = this.manager.clusterList[i] || i;\n                const cluster = newClusters.get(clusterId);\n                const oldCluster = this.manager.clusters.get(clusterId);\n                if (!cluster) continue;\n                if (oldCluster) {\n                    oldCluster.kill({ force: true, reason: 'reclustering' });\n                    oldClusters.delete(clusterId);\n                }\n                this.manager.clusters.set(clusterId, cluster);\n                cluster.triggerMaintenance();\n                this.manager._debug(\n                    `[↻][ReClustering][${clusterId}] Switched OldCluster to NewCluster and exited Maintenance Mode`,\n                );\n            }\n        }\n\n        newClusters.clear();\n        this.onProgress = false;\n        process.env.MAINTENANCE = undefined;\n        this.manager._debug('[↻][ReClustering] Finished ReClustering');\n        return { success: true };\n    }\n}\n"],"mappings":"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","names":["messageType","fetch","result","Worker_Thread","process","EventEmitter","path","script","error","import_worker_threads","error","import_events","EventEmitter","script","evalOptions","error","import_path","import_events","EventEmitter","path","fs","os","script","evalOptions"]}